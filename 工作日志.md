# 2024年终总结

> 2024入职以来，总体以学习为主，对公司文化，公司所用的单片机及相关设备有了越来越深入的学习和了解。并且着手开发机械手项目

## 一、51单片机

###  0.使用环境

+ 电脑：mac
+ 编辑器：vscode + platform io（8051支持）
+ 编译器：sdcc

### 1. stc15w4k48s2概览

> 进入公司接触到的第一款51单片机为stc15f2k60s2

其中单片机各项含义：

+ “W”：单片机电压范围更广，为5.5v-2.5v
+ "4k"：外部**RAM**的空间为4k
+ “48”：**FLASH** 空间位48k

### 2.单片机定时器使用

#### 2.1. 固定时间初始化

以定时器0为例：

+ TL0 + TH0：决定定时器初始值，加到65535为止定时器发送TF0标志位
+ TR0：标志位赋值为1开始计时
+ ET0：使能定时器0中断

~~~c
    AUXR |= 0x80; // 定时器时钟1T模式
    TMOD &= 0xF0; // 设置定时器模式
    TL0 = 0xAE;   // 设置定时初始值
    TH0 = 0xFB;   // 设置定时初始值
    TF0 = 0;      // 清除TF0标志
    TR0 = 1;      // 定时器0开始计时
    ET0 = 1;      // 使能定时器0中断
~~~
如果用定时器实现特定时间的延时，用for循环嵌套定时器计数代码，实现长时间的延时

#### 2.2. 可变时间初始化

==优点== ：能较快的实现段时间的可变时间延时，在us级别的可变定时任务中消耗的单片机资源更少并且相较于 **2.1.1** 延时更灵活

+ "reload" ：定时器设定时间，通过位移赋值给TL0 TH0;

~~~~c
    AUXR |= 0x80;      // 定时器时钟1T模式
    TMOD &= 0xF0;      // 设置定时器模式
    TL0 = reload;      // 设置定时初始值低8位
    TH0 = reload >> 8; // 设置定时初始值高8位
    TF0 = 0;           // 清除TF0标志
    TR0 = 1;           // 定时器0开始计时

    while (!TF0) // 等待定时器溢出
        ;

    TR0 = 0; // 停止定时器
    TF0 = 0; // 清除溢出标志
~~~~

### 3.串口的使用

串口是单片机与其他外设通信的根本

#### 3.1.串口初始化

~~~c
void Uart1_Init(void) // 57600bps@11.0592MHz
{
    SCON = 0x50;  // 8位数据,可变波特率
    AUXR |= 0x01; // 串口1选择定时器2为波特率发生器
    AUXR |= 0x04; // 定时器时钟1T模式
    T2L = 0xD0;   // 设置定时初始值
    T2H = 0xFF;   // 设置定时初始值
    AUXR |= 0x10; // 定时器2开始计时

    //IE2 |= 0x04; // 使能定时器2中断 ***
    EA = 1;
    ES = 1;
    REN = 1;
    IP = 0x10; // 串行口为高优先级中断
}
~~~

#### 3.2. 串口发送字节

1. 将字节存入**SBUF**中，**SBUF**进行发送
2. 等待TI标志位，若TI = 1，清除发送中断标志

~~~c
void Uart1_SendByte(char byte)
{
    SBUF = byte;
    while (!TI)
        ;   // 等待发送完成
    TI = 0; // 清除发送中断标志
}
~~~

#### 3.3 串口发送不限长度字符串

1. 获取字符串指针，从指针位置开始调用**3.2.**发送字节函数
2. 字节发送完成后，指针位置+1，开始发送下一个字节
3. 发送到字符串最后一位“0”为止结束

~~~c
void Uart1_SendString(const char *str) // 串口1发送不限长度字符串
{
    while (*str)
    {
        Uart1_SendByte(*str++);
    }
}
~~~

### 4. 中断的使用

中断用于处理异步事件。中断允许处理器在响应事件时暂停当前执行任务，处理事件后再返回继续执行。使得系统能够快速响应外部和内部事件，提高实时性能。

#### 4.1. 定时器中断

在定时器溢出时触发

#### 4.2 串口中断

实例代码用于接收迪文屏信息:

1. 串口接收到信息时，信息存入**SBUF**中，RI 标志位置1
2. 校验接受信息，详见“迪文屏”章节

~~~c
void Uart1_Isr(void) __interrupt(4) // 串口1中
{
    static unsigned char i;
    if (RI) // 接收中断
    {
        i = SBUF;
        RI = 0;
        if (RCVDATA == 0)
        {
            RX5A = RXA5;
            RXA5 = RXLEN;
            RXLEN = RXCMD;
            RXCMD = RXADRH;
            RXADRH = RXADRL;
            RXADRL = RXDLEN;
            RXDLEN = i;
            // 检查帧同步数据 5A A5 24 83 00 10 10 +32B DATA
            if ((RX5A == 0x5A) && (RXA5 == 0xA5) && (RXLEN) && (RXCMD == 0x83) && (RXADRH == 0x00) && (RXADRL) && (RXDLEN))
            {
                RCVDATA = 0xff;
                RX_P = RXADRL * 2;
                RXDLEN = RXDLEN * 2 + RX_P;
            }
        }
        else // 保存所有数据
        {
            CFGBUF[RX_P] = i;
            RX_P++;
            if (RX_P == RXDLEN)
            {
                RCVDATA = 0x00;
                RCVOK = 0xff;
            }
        }
    }
}
~~~

#### 4.3 外部中断

当io口接收到信号时触发，优先级最高

1. 外部中断初始化

~~~c
//初始化按键中断
void Interrupt0_Init(void)
{
	IT0 = 0;  // 0低电平触发 1高电平触发
    EX0 = 1;  // 使能外部中断 0
    EA = 1;   // 使能全局中断
}
~~~

2. 中断函数

~~~c
/*INT0	P3^2*/
void my_ISR(void) __interrupt (0) 
{
    int0_restart();
}
~~~

3. 中断业务：以触发外部中断重启单片机程序为例

~~~c
void int0_restart(void)
{
    if (P32 == 0) // 检测按键是否按下
    {
        DelayMs(2);   // 2ms消抖
        if (P32 == 0) // 再次检测按键是否按下
        {
            IAP_CONTR = 0x20; // stc15w重启
        }
    }
}
~~~

#### 4.4 中断优先级

